//! CESR file parsing using cesride library
//!
//! This module provides CESR (Composable Event Streaming Representation) parsing
//! functionality using the cesride library for better compatibility with files
//! generated by various KERI tools.

use cesride::{Matter, Prefixer};
use serde_json::Value;

/// Result of parsing a CESR file
#[derive(Debug, Clone)]
pub struct CesrKeys {
    pub private_key: Vec<u8>,
    pub public_key: Vec<u8>,
    pub did: String,
}

/// Parse CESR file and extract keys
///
/// Handles KERI event streams containing multiple JSON events.
/// Extracts public key from the first inception event (icp or dip).
///
/// **Note:** CESR files only contain public keys. Private key is returned
/// as zeros (mock) and must be provided separately for signing operations.
pub fn parse_cesr(cesr_data: &str) -> Result<CesrKeys, String> {
    let trimmed = cesr_data.trim();

    if trimmed.is_empty() {
        return Err("Empty CESR data".to_string());
    }

    // Check if this is a KERI event stream (starts with JSON)
    if trimmed.starts_with('{') {
        return parse_keri_event_stream(trimmed);
    }

    Err("Invalid CESR format. Expected KERI event stream starting with '{'".to_string())
}

/// Parse KERI event stream (multiple JSON events concatenated)
fn parse_keri_event_stream(data: &str) -> Result<CesrKeys, String> {
    let mut current_pos = 0;
    let data_bytes = data.as_bytes();
    let mut first_inception: Option<Value> = None;
    let mut delegated_inception: Option<Value> = None;

    // Parse each JSON object
    while current_pos < data_bytes.len() {
        // Skip whitespace and non-JSON characters
        while current_pos < data_bytes.len() && data_bytes[current_pos] != b'{' {
            current_pos += 1;
        }

        if current_pos >= data_bytes.len() {
            break;
        }

        // Find matching closing brace
        let start = current_pos;
        let mut depth = 0;
        let mut in_string = false;
        let mut escape = false;

        while current_pos < data_bytes.len() {
            let ch = data_bytes[current_pos];

            if escape {
                escape = false;
                current_pos += 1;
                continue;
            }

            if ch == b'\\' {
                escape = true;
            } else if ch == b'"' {
                in_string = !in_string;
            } else if !in_string {
                if ch == b'{' {
                    depth += 1;
                } else if ch == b'}' {
                    depth -= 1;
                    if depth == 0 {
                        current_pos += 1;
                        break;
                    }
                }
            }
            current_pos += 1;
        }

        // Parse this JSON object
        let json_str = &data[start..current_pos];
        if let Ok(event) = serde_json::from_str::<Value>(json_str) {
            // Check if this is an inception event
            if let Some(event_type) = event.get("t").and_then(|t| t.as_str()) {
                if event_type == "dip" && first_inception.is_none() {
                    first_inception = Some(event.clone());
                } else if event_type == "dip" && event.get("di").is_some() {
                    // This is a delegated inception with more keys
                    delegated_inception = Some(event);
                } else if event_type == "icp" && first_inception.is_none() {
                    first_inception = Some(event);
                }
            }
        }
    }

    // Prefer delegated inception if available (has more keys), otherwise first
    let inception_event = delegated_inception.or(first_inception);

    // Extract keys from inception event
    if let Some(event) = inception_event {
        return extract_keys_from_inception(event);
    }

    Err("No inception event found in CESR file. File might be corrupted or not a valid KERI event stream.".to_string())
}

/// Extract keys from KERI inception event using cesride
fn extract_keys_from_inception(event: Value) -> Result<CesrKeys, String> {
    // Get the DID (identifier)
    let did_identifier = event
        .get("i")
        .and_then(|i| i.as_str())
        .ok_or("Missing identifier 'i' in inception event")?;

    // Get public keys from 'k' field (array of keys)
    let keys = event
        .get("k")
        .and_then(|k| k.as_array())
        .ok_or("Missing keys 'k' in inception event")?;

    if keys.is_empty() {
        return Err("No keys found in inception event".to_string());
    }

    // Get first key (signing key) - CESR encoded
    let first_key_str = keys[0].as_str().ok_or("Invalid key format")?;

    // Use cesride Prefixer to parse CESR public key
    let prefixer = Prefixer::new_with_qb64(first_key_str)
        .map_err(|e| format!("Failed to parse CESR key with cesride: {:?}", e))?;

    // Get raw bytes from Prefixer
    let public_key_bytes = prefixer.raw();

    if public_key_bytes.len() != 32 {
        return Err(format!(
            "Expected 32 byte Ed25519 public key, got {} bytes",
            public_key_bytes.len()
        ));
    }

    // Create DID in standard format
    let did = format!("did:keri:{}", did_identifier);

    // Generate MOCK private key (zeros) since KERI files don't contain it
    // User MUST provide real private key separately for signing!
    let mock_private_key = vec![0u8; 32];

    eprintln!("✅ CESR file parsed successfully with cesride!");
    eprintln!("   DID: {}", did);
    eprintln!("   Public key: {} bytes", public_key_bytes.len());
    eprintln!("   ⚠️  Private key is MOCK (zeros) - provide real key for signing!");

    Ok(CesrKeys {
        private_key: mock_private_key,
        public_key: public_key_bytes.to_vec(),
        did,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_empty_cesr() {
        let result = parse_cesr("");
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Empty CESR data");
    }

    #[test]
    fn test_parse_invalid_format() {
        let result = parse_cesr("not a json");
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_keri_event_stream() {
        // This would need a real CESR file for testing
        // For now, just ensure the function exists and has correct signature
        let result = parse_cesr("{}");
        assert!(result.is_err());
    }
}
