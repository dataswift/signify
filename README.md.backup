# Trustex

[![Hex.pm](https://img.shields.io/hexpm/v/trustex.svg)](https://hex.pm/packages/trustex)
[![Documentation](https://img.shields.io/badge/docs-hexdocs-blue.svg)](https://hexdocs.pm/trustex)

**W3C Verifiable Credentials signing and verification using Ed25519 and CESR.**

Trust-based identity verification for legal entities and individuals.

## What is Trustex?

Trustex is an Elixir library for creating and verifying **W3C Verifiable Credentials** using Ed25519 cryptography with CESR (Composable Event Streaming Representation) key storage.

Think of it as **JWT for verifiable identity credentials** - but with stronger cryptography and W3C standards compliance.

## Features

- âœ… **W3C Verifiable Credentials** - Standard-compliant credential creation
- âœ… **Ed25519 Signatures** - Fast and secure cryptographic signing  
- âœ… **KERI CESR Support** - Load and parse KERI credential files
- âœ… **DID (Decentralized Identifiers)** - Full `did:keri:...` CESR format support
- âœ… **Signature Verification** - Verify credentials and presentations using public keys
- âœ… **vLEI Support** - Verifiable Legal Entity Identifier credentials
- âœ… **Rust NIF** - High-performance cryptography through Rustler + cesride
- âœ… **Automatic VP Creation** - Generate complete Verifiable Presentations with one function call

## Installation

Add `trustex` to your list of dependencies in `mix.exs`:

```elixir
def deps do
  [
    {:trustex, "~> 0.1.0"}
  ]
end
```

Then run:

```bash
mix deps.get
mix compile
```

**Note:** Requires Rust to be installed for NIF compilation.

## Quick Start

### Option 1: With KERI Credential File (Production)

```elixir
# Load public key from KERI credential.cesr file
{:ok, keys} = Trustex.Signer.load_keys_from_file("credential.cesr")
# keys.did = "did:keri:..." (extracted from CESR file)

# Verify a signed Verifiable Presentation
{:ok, valid?} = Trustex.Credentials.verify_presentation(signed_vp)
```

### Option 2: Generate New Keys (Testing/Development)

```elixir
# Generate keypair
{:ok, keys} = Trustex.Signer.generate_keypair()

# Create and sign Verifiable Presentation with custom payload
{:ok, vp} = Trustex.Credentials.create_and_sign_presentation(
  [],  # verifiable credentials (optional)
  keys,
  challenge: "random-challenge-123",
  domain: "https://example.com",
  custom_payload: %{
    email: "user@example.com",
    role: "agripreneur",
    ap_score: 967
  }
)

# Verify
{:ok, true} = Trustex.Credentials.verify_presentation(vp)
```

## Usage Examples

### 1. Load Keys from KERI Credential File

```elixir
# Load public key from KERI credential.cesr file
{:ok, keys} = Trustex.Signer.load_keys_from_file("credential.cesr")

# Keys structure
%Trustex.Signer.CESRKeys{
  private_key: <<...>>,  # MOCK (zeros) - KERI files don't contain private keys
  public_key: <<...>>,   # 32 bytes - extracted from CESR
  did: "did:keri:..."    # DID identifier from CESR file
}
```

**Important:** KERI credential files contain **ONLY public keys** for security. Private keys are stored separately in secure wallets/HSM.

For testing/development, generate new keys:

```elixir
# Generate new keypair (for testing)
{:ok, keys} = Trustex.Signer.generate_keypair()
# DID format: "did:keri:..." (CESR encoded public key)
```

### 2. Create and Sign Verifiable Credential

```elixir
# Define credential subject (the person/entity)
credential_subject = %{
  id: keys.did,
  email: "farmer@example.com",
  role: "agripreneur",
  first_name: "John",
  last_name: "Doe",
  ap_score: 967,
  region: "Coast"
}

# Create and sign the credential
{:ok, credential} = Trustex.Credentials.create_and_sign(
  credential_subject,
  keys,
  issuer: %{id: keys.did, name: "Kuza Biashara Limited"},
  type: ["VerifiableCredential", "AgripreneurCredential"],
  expiration_date: ~U[2026-01-01 00:00:00Z]
)
```

### 3. Verify Credentials

```elixir
# Verify a credential
{:ok, true} = Trustex.Credentials.verify_credential(credential)

# Verify fails for tampered credentials
tampered = Map.put(credential, :credentialSubject, %{id: keys.did, email: "hacked@evil.com"})
{:ok, false} = Trustex.Credentials.verify_credential(tampered)
```

### 4. Create Verifiable Presentation

Presentation combines multiple credentials:

```elixir
# Create multiple credentials
{:ok, role_credential} = Trustex.Credentials.create_and_sign(
  %{id: keys.did, role: "agripreneur"},
  keys,
  issuer: %{id: keys.did, name: "Kuza Biashara"},
  type: ["VerifiableCredential", "RoleCredential"]
)

{:ok, profile_credential} = Trustex.Credentials.create_and_sign(
  %{id: keys.did, first_name: "John", last_name: "Doe"},
  keys,
  issuer: %{id: keys.did, name: "Kuza Biashara"},
  type: ["VerifiableCredential", "ProfileCredential"]
)

# Create presentation with custom payload
{:ok, presentation} = Trustex.Credentials.create_and_sign_presentation(
  [role_credential, profile_credential],
  keys,
  challenge: "efae261a-89ec-428e-a854-c2d64037270c",
  domain: "https://trade-portal.kuzabiashara.co.ke",
  custom_payload: %{
    ap_spg_score: 967,
    ap_transactions_number: 10,
    email: "demo@example.com"
  }
)

# Verify presentation
{:ok, true} = Trustex.Credentials.verify_presentation(presentation)
```

### 5. vLEI (Legal Entity) Credentials

Create verifiable credentials for legal entities:

```elixir
lei_data = %{
  LEI: "98450012E89468BE9808",
  legalName: "KUZA BIASHARA LIMITED",
  entityStatus: "ACTIVE",
  entityCategory: "GENERAL",
  entityCreationDate: "2011-10-14T01:00:00+01:00",
  legalAddress: %{
    addressLines: ["P.O BOX 1772 SARIT CENTRE"],
    city: "WESTLANDS DISTRICT",
    country: "KE",
    postalCode: "00100",
    region: "KE-30",
    language: "en"
  },
  legalForm: %{
    code: "8888",
    label: "Private Limited Company"
  },
  registrationAuthority: %{
    jurisdiction: "KE",
    registrationAuthorityID: "RA000417",
    registrationAuthorityEntityID: "CPR/2011/58834"
  }
}

{:ok, vlei_credential} = Trustex.Credentials.create_vlei_credential(
  lei_data,
  keys,
  issuer: %{
    id: keys.did,
    name: "Qualified vLEI Issuer",
    LEI: "529900T8BM49AURSDO55"
  },
  expiration_date: ~U[2025-08-15 10:45:00Z]
)
```

### 6. Low-Level Signing

For custom signing scenarios:

```elixir
# Sign any JSON data
data = %{message: "Hello, Trustex!", timestamp: DateTime.utc_now(), counter: 42}
{:ok, proof} = Trustex.Signer.sign(keys, data)

# Verify with DID
json = Jason.encode!(data)
{:ok, true} = Trustex.Signer.verify(keys.did, json, proof.proof_value)

# Extract public key from DID
{:ok, public_key} = Trustex.Signer.extract_public_key_from_did(keys.did)
{:ok, true} = Trustex.Signer.verify_json(public_key, json, proof.proof_value)
```

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Your Elixir Application        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Trustex.Credentials            â”‚ â† W3C VC/VP Logic
â”‚  (Elixir)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Trustex.Signer                 â”‚ â† NIF Wrapper
â”‚  (Elixir)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  trustex_native (Rust NIF)      â”‚ â† Cryptography
â”‚  - Ed25519 signing/verification â”‚
â”‚  - CESR parsing                 â”‚
â”‚  - DID generation               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Modules

### Trustex.Signer

Low-level signing and verification:

- `generate_keypair/0` - Generate new Ed25519 keypair
- `load_keys_from_file/1` - Load keys from CESR file
- `sign/2` - Sign JSON data
- `verify/3` - Verify signature
- `extract_public_key_from_did/1` - Extract public key from DID

### Trustex.Credentials

High-level W3C Verifiable Credentials:

- `create_and_sign/3` - Create and sign VC
- `create_and_sign_presentation/3` - Create and sign VP
- `create_vlei_credential/3` - Create vLEI credential
- `verify_credential/1` - Verify VC signature
- `verify_presentation/1` - Verify VP signature

### Trustex.Examples

Usage examples for learning and testing.

## CESR File Format

Trustex supports simplified CESR files:

**Hex-encoded private key (64 hex characters = 32 bytes):**
```
a3b4c5d6e7f8901234567890abcdef1234567890abcdef1234567890abcdef12
```

The public key and DID are automatically derived from the private key.

## JWT vs Trustex

| Feature | JWT | Trustex |
|---------|-----|---------|
| Format | Compact token | JSON document |
| Standard | IETF RFC | W3C Recommendation |
| Crypto | HMAC/RSA/ES256 | Ed25519 |
| Key Management | Secrets | CESR files/DIDs |
| Revocation | Manual | credentialStatus |
| DIDs | No | Yes (did:keri:...) |
| Selective Disclosure | No | Possible |
| Composability | Limited | High (presentations) |

## Use Cases

- **Legal Entity Verification** - vLEI credentials for businesses
- **Role-based Credentials** - Employee/member roles
- **Academic Credentials** - Certificates, diplomas
- **Supply Chain** - Provenance tracking
- **Identity Verification** - KYC/AML compliance
- **Access Control** - Permission management
- **Digital Signatures** - Document signing

## Performance

Ed25519 signatures are extremely fast:

- **Signing:** ~15-20Î¼s per signature
- **Verification:** ~50-70Î¼s per verification
- **Key generation:** ~10Î¼s

Rust NIF provides near-native performance (~25-50x faster than pure Elixir crypto).

## Limitations

This is an MVP implementation with some limitations:

- âš ï¸ **CESR Parser** - Simplified, supports basic formats
- âš ï¸ **JSON-LD Canonicalization** - Simplified (JSON stringify)
- âš ï¸ **DID Method** - Simplified `did:keri`, not full KERI
- âš ï¸ **No Key Rotation** - KERI KEL not implemented
- âš ï¸ **No Revocation Checking** - credentialStatus not implemented

For production use with full KERI, consider using KERIA HTTP API alongside Trustex.

## Examples

The `examples/` directory contains working demonstrations:

### Load and Verify with KERI Credential

```bash
# Load public key from credential.cesr and show info
mix run examples/load_keri_cesr.exs

# Verify signed VP using credential.cesr public key
mix run examples/sign_and_verify.exs
```

### Benchmarks

```bash
# Run performance benchmarks
make bench

# Or directly
mix run bench/trustex_bench.exs
```

**Benchmark Results:**
- `generate_keypair`: ~15.69 Î¼s (63.72K ips)
- `sign_json`: ~42.66 Î¼s (23.44K ips)
- `verify_signature`: ~46.50 Î¼s (21.51K ips)

## Working with KERI Credentials

### Understanding KERI Credential Files

KERI credential files (`.cesr`) contain:
- âœ… **Public keys** - Used for signature verification
- âœ… **DID identifiers** - `did:keri:...` in CESR format
- âœ… **Inception events** - KERI event history
- âŒ **NO private keys** - Stored separately for security

### Typical Workflow

**1. For Verification (Using credential.cesr):**

```elixir
# Load public key from KERI credential file
{:ok, keys} = Trustex.Signer.load_keys_from_file("credential.cesr")

# Receive signed VP (from API, database, etc.)
signed_vp = receive_vp_from_somewhere()

# Verify signature using public key from credential.cesr
{:ok, valid?} = Trustex.Credentials.verify_presentation(signed_vp)

if valid? do
  IO.puts("âœ… VP was signed by: #{keys.did}")
else
  IO.puts("âŒ Invalid signature!")
end
```

**2. For Signing (Private key from secure wallet):**

```elixir
# Load public key from credential.cesr
{:ok, cesr_keys} = Trustex.Signer.load_keys_from_file("credential.cesr")

# Get private key from secure wallet/HSM (not in credential.cesr!)
private_key = get_from_secure_wallet(cesr_keys.did)

# Create signing keys
signing_keys = %Trustex.Signer.CESRKeys{
  private_key: private_key,
  public_key: cesr_keys.public_key,
  did: cesr_keys.did
}

# Sign VP
{:ok, vp} = Trustex.Credentials.create_and_sign_presentation(
  [],
  signing_keys,
  custom_payload: %{email: "user@example.com", role: "agripreneur"}
)
```

### Why Separate Private Keys?

ðŸ”’ **Security Best Practice:**
- KERI credential files are shared publicly or semi-publicly
- Private keys MUST be stored in secure wallets/HSM
- Only the owner has the private key
- Anyone can verify signatures using the public key from credential.cesr

This is similar to SSH keys: `id_rsa.pub` (public, shareable) vs `id_rsa` (private, secret).

## Development

### Prerequisites

- Elixir ~> 1.18
- Rust 1.70+
- Jason ~> 1.4

### Setup

```bash
git clone https://github.com/yourusername/trustex.git
cd trustex
mix deps.get
mix compile
mix test
```

### Testing

```bash
# Run tests
mix test

# Run examples
mix run examples/load_keri_cesr.exs
mix run examples/sign_and_verify.exs

# Run benchmarks
make bench

# Check types
mix dialyzer

# Lint code
mix credo
```

## Contributing

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Submit a pull request

## Resources

- [W3C Verifiable Credentials](https://www.w3.org/TR/vc-data-model/)
- [KERI](https://keri.one/)
- [CESR Specification](https://datatracker.ietf.org/doc/html/draft-ssmith-cesr)
- [vLEI](https://www.gleif.org/en/lei-solutions/gleifs-digital-strategy-for-the-lei)
- [Ed25519](https://ed25519.cr.yp.to/)

## License

MIT License - see LICENSE file for details.

## Authors

- Your Team

## Acknowledgments

- W3C for Verifiable Credentials specification
- GLEIF for vLEI standards
- Elixir and Rust communities
